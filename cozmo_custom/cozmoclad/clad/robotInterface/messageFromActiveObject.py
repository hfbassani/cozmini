# Copyright (c) 2016-2017 Anki, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License in the file LICENSE.txt or at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Autogenerated python message buffer code.
Source: clad/robotInterface/messageFromActiveObject.clad
Full command line: '../tools/message-buffers/emitters/Python_emitter.py' '-C' '../robot/clad/src/' '-o' '../generated/cladPython//' 'clad/robotInterface/messageFromActiveObject.clad'
"""

from __future__ import absolute_import
from __future__ import print_function

def _modify_path():
  import inspect, os, sys
  search_paths = [
    '../..',
    '../../../../tools/message-buffers/support/python',
  ]
  currentpath = os.path.abspath(os.path.dirname(inspect.getfile(inspect.currentframe())))
  for search_path in search_paths:
    search_path = os.path.normpath(os.path.abspath(os.path.realpath(os.path.join(currentpath, search_path))))
    if search_path not in sys.path:
      sys.path.insert(0, search_path)
_modify_path()

import msgbuffers

Anki = msgbuffers.Namespace()
Anki.Cozmo = msgbuffers.Namespace()

from clad.types.activeObjectAccel import Anki as _Anki
Anki.update(_Anki.deep_clone())

from clad.types.objectTypes import Anki as _Anki
Anki.update(_Anki.deep_clone())

class ObjectAvailable(object):
  "Generated message-passing message."

  __slots__ = (
    '_factory_id', # uint_32
    '_objectType', # Anki.Cozmo.ObjectType
    '_rssi',       # int_8
  )

  @property
  def factory_id(self):
    "uint_32 factory_id struct property."
    return self._factory_id

  @factory_id.setter
  def factory_id(self, value):
    self._factory_id = msgbuffers.validate_integer(
      'ObjectAvailable.factory_id', value, 0, 4294967295)

  @property
  def objectType(self):
    "Anki.Cozmo.ObjectType objectType struct property."
    return self._objectType

  @objectType.setter
  def objectType(self, value):
    self._objectType = msgbuffers.validate_integer(
      'ObjectAvailable.objectType', value, -2147483648, 2147483647)

  @property
  def rssi(self):
    "int_8 rssi struct property."
    return self._rssi

  @rssi.setter
  def rssi(self, value):
    self._rssi = msgbuffers.validate_integer(
      'ObjectAvailable.rssi', value, -128, 127)

  def __init__(self, factory_id=0, objectType=Anki.Cozmo.ObjectType.InvalidObject, rssi=0):
    self.factory_id = factory_id
    self.objectType = objectType
    self.rssi = rssi

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ObjectAvailable from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ObjectAvailable.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ObjectAvailable from the given BinaryReader."
    _factory_id = reader.read('I')
    _objectType = reader.read('i')
    _rssi = reader.read('b')
    return cls(_factory_id, _objectType, _rssi)

  def pack(self):
    "Writes the current ObjectAvailable, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ObjectAvailable to the given BinaryWriter."
    writer.write(self._factory_id, 'I')
    writer.write(self._objectType, 'i')
    writer.write(self._rssi, 'b')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._factory_id == other._factory_id and
        self._objectType == other._objectType and
        self._rssi == other._rssi)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._factory_id, 'I') +
      msgbuffers.size(self._objectType, 'i') +
      msgbuffers.size(self._rssi, 'b'))

  def __str__(self):
    return '{type}(factory_id={factory_id}, objectType={objectType}, rssi={rssi})'.format(
      type=type(self).__name__,
      factory_id=self._factory_id,
      objectType=self._objectType,
      rssi=self._rssi)

  def __repr__(self):
    return '{type}(factory_id={factory_id}, objectType={objectType}, rssi={rssi})'.format(
      type=type(self).__name__,
      factory_id=repr(self._factory_id),
      objectType=repr(self._objectType),
      rssi=repr(self._rssi))

Anki.Cozmo.ObjectAvailable = ObjectAvailable
del ObjectAvailable


class ObjectConnectionState(object):
  "Generated message-passing message."

  __slots__ = (
    '_objectID',    # uint_32
    '_factoryID',   # uint_32
    '_object_type', # Anki.Cozmo.ObjectType
    '_connected',   # bool
  )

  @property
  def objectID(self):
    "uint_32 objectID struct property."
    return self._objectID

  @objectID.setter
  def objectID(self, value):
    self._objectID = msgbuffers.validate_integer(
      'ObjectConnectionState.objectID', value, 0, 4294967295)

  @property
  def factoryID(self):
    "uint_32 factoryID struct property."
    return self._factoryID

  @factoryID.setter
  def factoryID(self, value):
    self._factoryID = msgbuffers.validate_integer(
      'ObjectConnectionState.factoryID', value, 0, 4294967295)

  @property
  def object_type(self):
    "Anki.Cozmo.ObjectType object_type struct property."
    return self._object_type

  @object_type.setter
  def object_type(self, value):
    self._object_type = msgbuffers.validate_integer(
      'ObjectConnectionState.object_type', value, -2147483648, 2147483647)

  @property
  def connected(self):
    "bool connected struct property."
    return self._connected

  @connected.setter
  def connected(self, value):
    self._connected = msgbuffers.validate_bool(
      'ObjectConnectionState.connected', value)

  def __init__(self, objectID=0, factoryID=0, object_type=Anki.Cozmo.ObjectType.InvalidObject, connected=False):
    self.objectID = objectID
    self.factoryID = factoryID
    self.object_type = object_type
    self.connected = connected

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ObjectConnectionState from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ObjectConnectionState.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ObjectConnectionState from the given BinaryReader."
    _objectID = reader.read('I')
    _factoryID = reader.read('I')
    _object_type = reader.read('i')
    _connected = bool(reader.read('b'))
    return cls(_objectID, _factoryID, _object_type, _connected)

  def pack(self):
    "Writes the current ObjectConnectionState, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ObjectConnectionState to the given BinaryWriter."
    writer.write(self._objectID, 'I')
    writer.write(self._factoryID, 'I')
    writer.write(self._object_type, 'i')
    writer.write(int(self._connected), 'b')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._objectID == other._objectID and
        self._factoryID == other._factoryID and
        self._object_type == other._object_type and
        self._connected == other._connected)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._objectID, 'I') +
      msgbuffers.size(self._factoryID, 'I') +
      msgbuffers.size(self._object_type, 'i') +
      msgbuffers.size(self._connected, 'b'))

  def __str__(self):
    return '{type}(objectID={objectID}, factoryID={factoryID}, object_type={object_type}, connected={connected})'.format(
      type=type(self).__name__,
      objectID=self._objectID,
      factoryID=self._factoryID,
      object_type=self._object_type,
      connected=self._connected)

  def __repr__(self):
    return '{type}(objectID={objectID}, factoryID={factoryID}, object_type={object_type}, connected={connected})'.format(
      type=type(self).__name__,
      objectID=repr(self._objectID),
      factoryID=repr(self._factoryID),
      object_type=repr(self._object_type),
      connected=repr(self._connected))

Anki.Cozmo.ObjectConnectionState = ObjectConnectionState
del ObjectConnectionState


class ObjectConnectionStateToRobot(object):
  "Generated message-passing message."

  __slots__ = (
    '_objectID',    # uint_32
    '_factoryID',   # uint_32
    '_object_type', # Anki.Cozmo.ObjectType
    '_connected',   # bool
  )

  @property
  def objectID(self):
    "uint_32 objectID struct property."
    return self._objectID

  @objectID.setter
  def objectID(self, value):
    self._objectID = msgbuffers.validate_integer(
      'ObjectConnectionStateToRobot.objectID', value, 0, 4294967295)

  @property
  def factoryID(self):
    "uint_32 factoryID struct property."
    return self._factoryID

  @factoryID.setter
  def factoryID(self, value):
    self._factoryID = msgbuffers.validate_integer(
      'ObjectConnectionStateToRobot.factoryID', value, 0, 4294967295)

  @property
  def object_type(self):
    "Anki.Cozmo.ObjectType object_type struct property."
    return self._object_type

  @object_type.setter
  def object_type(self, value):
    self._object_type = msgbuffers.validate_integer(
      'ObjectConnectionStateToRobot.object_type', value, -2147483648, 2147483647)

  @property
  def connected(self):
    "bool connected struct property."
    return self._connected

  @connected.setter
  def connected(self, value):
    self._connected = msgbuffers.validate_bool(
      'ObjectConnectionStateToRobot.connected', value)

  def __init__(self, objectID=0, factoryID=0, object_type=Anki.Cozmo.ObjectType.InvalidObject, connected=False):
    self.objectID = objectID
    self.factoryID = factoryID
    self.object_type = object_type
    self.connected = connected

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ObjectConnectionStateToRobot from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ObjectConnectionStateToRobot.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ObjectConnectionStateToRobot from the given BinaryReader."
    _objectID = reader.read('I')
    _factoryID = reader.read('I')
    _object_type = reader.read('i')
    _connected = bool(reader.read('b'))
    return cls(_objectID, _factoryID, _object_type, _connected)

  def pack(self):
    "Writes the current ObjectConnectionStateToRobot, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ObjectConnectionStateToRobot to the given BinaryWriter."
    writer.write(self._objectID, 'I')
    writer.write(self._factoryID, 'I')
    writer.write(self._object_type, 'i')
    writer.write(int(self._connected), 'b')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._objectID == other._objectID and
        self._factoryID == other._factoryID and
        self._object_type == other._object_type and
        self._connected == other._connected)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._objectID, 'I') +
      msgbuffers.size(self._factoryID, 'I') +
      msgbuffers.size(self._object_type, 'i') +
      msgbuffers.size(self._connected, 'b'))

  def __str__(self):
    return '{type}(objectID={objectID}, factoryID={factoryID}, object_type={object_type}, connected={connected})'.format(
      type=type(self).__name__,
      objectID=self._objectID,
      factoryID=self._factoryID,
      object_type=self._object_type,
      connected=self._connected)

  def __repr__(self):
    return '{type}(objectID={objectID}, factoryID={factoryID}, object_type={object_type}, connected={connected})'.format(
      type=type(self).__name__,
      objectID=repr(self._objectID),
      factoryID=repr(self._factoryID),
      object_type=repr(self._object_type),
      connected=repr(self._connected))

Anki.Cozmo.ObjectConnectionStateToRobot = ObjectConnectionStateToRobot
del ObjectConnectionStateToRobot


class ObjectMoved(object):
  "Generated message-passing message."

  __slots__ = (
    '_timestamp',   # uint_32
    '_objectID',    # uint_32
    '_accel',       # Anki.Cozmo.ActiveAccel
    '_axisOfAccel', # Anki.Cozmo.UpAxis
  )

  @property
  def timestamp(self):
    "uint_32 timestamp struct property."
    return self._timestamp

  @timestamp.setter
  def timestamp(self, value):
    self._timestamp = msgbuffers.validate_integer(
      'ObjectMoved.timestamp', value, 0, 4294967295)

  @property
  def objectID(self):
    "uint_32 objectID struct property."
    return self._objectID

  @objectID.setter
  def objectID(self, value):
    self._objectID = msgbuffers.validate_integer(
      'ObjectMoved.objectID', value, 0, 4294967295)

  @property
  def accel(self):
    "Anki.Cozmo.ActiveAccel accel struct property."
    return self._accel

  @accel.setter
  def accel(self, value):
    self._accel = msgbuffers.validate_object(
      'ObjectMoved.accel', value, Anki.Cozmo.ActiveAccel)

  @property
  def axisOfAccel(self):
    "Anki.Cozmo.UpAxis axisOfAccel struct property."
    return self._axisOfAccel

  @axisOfAccel.setter
  def axisOfAccel(self, value):
    self._axisOfAccel = msgbuffers.validate_integer(
      'ObjectMoved.axisOfAccel', value, 0, 255)

  def __init__(self, timestamp=0, objectID=0, accel=Anki.Cozmo.ActiveAccel(), axisOfAccel=Anki.Cozmo.UpAxis.XNegative):
    self.timestamp = timestamp
    self.objectID = objectID
    self.accel = accel
    self.axisOfAccel = axisOfAccel

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ObjectMoved from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ObjectMoved.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ObjectMoved from the given BinaryReader."
    _timestamp = reader.read('I')
    _objectID = reader.read('I')
    _accel = reader.read_object(Anki.Cozmo.ActiveAccel.unpack_from)
    _axisOfAccel = reader.read('B')
    return cls(_timestamp, _objectID, _accel, _axisOfAccel)

  def pack(self):
    "Writes the current ObjectMoved, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ObjectMoved to the given BinaryWriter."
    writer.write(self._timestamp, 'I')
    writer.write(self._objectID, 'I')
    writer.write_object(self._accel)
    writer.write(self._axisOfAccel, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._timestamp == other._timestamp and
        self._objectID == other._objectID and
        self._accel == other._accel and
        self._axisOfAccel == other._axisOfAccel)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._timestamp, 'I') +
      msgbuffers.size(self._objectID, 'I') +
      msgbuffers.size_object(self._accel) +
      msgbuffers.size(self._axisOfAccel, 'B'))

  def __str__(self):
    return '{type}(timestamp={timestamp}, objectID={objectID}, accel={accel}, axisOfAccel={axisOfAccel})'.format(
      type=type(self).__name__,
      timestamp=self._timestamp,
      objectID=self._objectID,
      accel=self._accel,
      axisOfAccel=self._axisOfAccel)

  def __repr__(self):
    return '{type}(timestamp={timestamp}, objectID={objectID}, accel={accel}, axisOfAccel={axisOfAccel})'.format(
      type=type(self).__name__,
      timestamp=repr(self._timestamp),
      objectID=repr(self._objectID),
      accel=repr(self._accel),
      axisOfAccel=repr(self._axisOfAccel))

Anki.Cozmo.ObjectMoved = ObjectMoved
del ObjectMoved


class ObjectStoppedMoving(object):
  "Generated message-passing message."

  __slots__ = (
    '_timestamp', # uint_32
    '_objectID',  # uint_32
  )

  @property
  def timestamp(self):
    "uint_32 timestamp struct property."
    return self._timestamp

  @timestamp.setter
  def timestamp(self, value):
    self._timestamp = msgbuffers.validate_integer(
      'ObjectStoppedMoving.timestamp', value, 0, 4294967295)

  @property
  def objectID(self):
    "uint_32 objectID struct property."
    return self._objectID

  @objectID.setter
  def objectID(self, value):
    self._objectID = msgbuffers.validate_integer(
      'ObjectStoppedMoving.objectID', value, 0, 4294967295)

  def __init__(self, timestamp=0, objectID=0):
    self.timestamp = timestamp
    self.objectID = objectID

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ObjectStoppedMoving from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ObjectStoppedMoving.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ObjectStoppedMoving from the given BinaryReader."
    _timestamp = reader.read('I')
    _objectID = reader.read('I')
    return cls(_timestamp, _objectID)

  def pack(self):
    "Writes the current ObjectStoppedMoving, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ObjectStoppedMoving to the given BinaryWriter."
    writer.write(self._timestamp, 'I')
    writer.write(self._objectID, 'I')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._timestamp == other._timestamp and
        self._objectID == other._objectID)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._timestamp, 'I') +
      msgbuffers.size(self._objectID, 'I'))

  def __str__(self):
    return '{type}(timestamp={timestamp}, objectID={objectID})'.format(
      type=type(self).__name__,
      timestamp=self._timestamp,
      objectID=self._objectID)

  def __repr__(self):
    return '{type}(timestamp={timestamp}, objectID={objectID})'.format(
      type=type(self).__name__,
      timestamp=repr(self._timestamp),
      objectID=repr(self._objectID))

Anki.Cozmo.ObjectStoppedMoving = ObjectStoppedMoving
del ObjectStoppedMoving


class ObjectUpAxisChanged(object):
  "Generated message-passing message."

  __slots__ = (
    '_timestamp', # uint_32
    '_objectID',  # uint_32
    '_upAxis',    # Anki.Cozmo.UpAxis
  )

  @property
  def timestamp(self):
    "uint_32 timestamp struct property."
    return self._timestamp

  @timestamp.setter
  def timestamp(self, value):
    self._timestamp = msgbuffers.validate_integer(
      'ObjectUpAxisChanged.timestamp', value, 0, 4294967295)

  @property
  def objectID(self):
    "uint_32 objectID struct property."
    return self._objectID

  @objectID.setter
  def objectID(self, value):
    self._objectID = msgbuffers.validate_integer(
      'ObjectUpAxisChanged.objectID', value, 0, 4294967295)

  @property
  def upAxis(self):
    "Anki.Cozmo.UpAxis upAxis struct property."
    return self._upAxis

  @upAxis.setter
  def upAxis(self, value):
    self._upAxis = msgbuffers.validate_integer(
      'ObjectUpAxisChanged.upAxis', value, 0, 255)

  def __init__(self, timestamp=0, objectID=0, upAxis=Anki.Cozmo.UpAxis.XNegative):
    self.timestamp = timestamp
    self.objectID = objectID
    self.upAxis = upAxis

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ObjectUpAxisChanged from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ObjectUpAxisChanged.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ObjectUpAxisChanged from the given BinaryReader."
    _timestamp = reader.read('I')
    _objectID = reader.read('I')
    _upAxis = reader.read('B')
    return cls(_timestamp, _objectID, _upAxis)

  def pack(self):
    "Writes the current ObjectUpAxisChanged, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ObjectUpAxisChanged to the given BinaryWriter."
    writer.write(self._timestamp, 'I')
    writer.write(self._objectID, 'I')
    writer.write(self._upAxis, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._timestamp == other._timestamp and
        self._objectID == other._objectID and
        self._upAxis == other._upAxis)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._timestamp, 'I') +
      msgbuffers.size(self._objectID, 'I') +
      msgbuffers.size(self._upAxis, 'B'))

  def __str__(self):
    return '{type}(timestamp={timestamp}, objectID={objectID}, upAxis={upAxis})'.format(
      type=type(self).__name__,
      timestamp=self._timestamp,
      objectID=self._objectID,
      upAxis=self._upAxis)

  def __repr__(self):
    return '{type}(timestamp={timestamp}, objectID={objectID}, upAxis={upAxis})'.format(
      type=type(self).__name__,
      timestamp=repr(self._timestamp),
      objectID=repr(self._objectID),
      upAxis=repr(self._upAxis))

Anki.Cozmo.ObjectUpAxisChanged = ObjectUpAxisChanged
del ObjectUpAxisChanged


class ObjectTappedFiltered(object):
  "Generated message-passing message."

  __slots__ = (
    '_timestamp',    # uint_32
    '_objectID',     # uint_32
    '_tapTime',      # uint_8
    '_tapIntensity', # uint_8
  )

  @property
  def timestamp(self):
    "uint_32 timestamp struct property."
    return self._timestamp

  @timestamp.setter
  def timestamp(self, value):
    self._timestamp = msgbuffers.validate_integer(
      'ObjectTappedFiltered.timestamp', value, 0, 4294967295)

  @property
  def objectID(self):
    "uint_32 objectID struct property."
    return self._objectID

  @objectID.setter
  def objectID(self, value):
    self._objectID = msgbuffers.validate_integer(
      'ObjectTappedFiltered.objectID', value, 0, 4294967295)

  @property
  def tapTime(self):
    "uint_8 tapTime struct property."
    return self._tapTime

  @tapTime.setter
  def tapTime(self, value):
    self._tapTime = msgbuffers.validate_integer(
      'ObjectTappedFiltered.tapTime', value, 0, 255)

  @property
  def tapIntensity(self):
    "uint_8 tapIntensity struct property."
    return self._tapIntensity

  @tapIntensity.setter
  def tapIntensity(self, value):
    self._tapIntensity = msgbuffers.validate_integer(
      'ObjectTappedFiltered.tapIntensity', value, 0, 255)

  def __init__(self, timestamp=0, objectID=0, tapTime=0, tapIntensity=0):
    self.timestamp = timestamp
    self.objectID = objectID
    self.tapTime = tapTime
    self.tapIntensity = tapIntensity

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ObjectTappedFiltered from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ObjectTappedFiltered.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ObjectTappedFiltered from the given BinaryReader."
    _timestamp = reader.read('I')
    _objectID = reader.read('I')
    _tapTime = reader.read('B')
    _tapIntensity = reader.read('B')
    return cls(_timestamp, _objectID, _tapTime, _tapIntensity)

  def pack(self):
    "Writes the current ObjectTappedFiltered, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ObjectTappedFiltered to the given BinaryWriter."
    writer.write(self._timestamp, 'I')
    writer.write(self._objectID, 'I')
    writer.write(self._tapTime, 'B')
    writer.write(self._tapIntensity, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._timestamp == other._timestamp and
        self._objectID == other._objectID and
        self._tapTime == other._tapTime and
        self._tapIntensity == other._tapIntensity)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._timestamp, 'I') +
      msgbuffers.size(self._objectID, 'I') +
      msgbuffers.size(self._tapTime, 'B') +
      msgbuffers.size(self._tapIntensity, 'B'))

  def __str__(self):
    return '{type}(timestamp={timestamp}, objectID={objectID}, tapTime={tapTime}, tapIntensity={tapIntensity})'.format(
      type=type(self).__name__,
      timestamp=self._timestamp,
      objectID=self._objectID,
      tapTime=self._tapTime,
      tapIntensity=self._tapIntensity)

  def __repr__(self):
    return '{type}(timestamp={timestamp}, objectID={objectID}, tapTime={tapTime}, tapIntensity={tapIntensity})'.format(
      type=type(self).__name__,
      timestamp=repr(self._timestamp),
      objectID=repr(self._objectID),
      tapTime=repr(self._tapTime),
      tapIntensity=repr(self._tapIntensity))

Anki.Cozmo.ObjectTappedFiltered = ObjectTappedFiltered
del ObjectTappedFiltered


class ObjectTapped(object):
  "Generated message-passing message."

  __slots__ = (
    '_timestamp', # uint_32
    '_objectID',  # uint_32
    '_numTaps',   # uint_8
    '_tapTime',   # uint_8
    '_tapNeg',    # int_8
    '_tapPos',    # int_8
  )

  @property
  def timestamp(self):
    "uint_32 timestamp struct property."
    return self._timestamp

  @timestamp.setter
  def timestamp(self, value):
    self._timestamp = msgbuffers.validate_integer(
      'ObjectTapped.timestamp', value, 0, 4294967295)

  @property
  def objectID(self):
    "uint_32 objectID struct property."
    return self._objectID

  @objectID.setter
  def objectID(self, value):
    self._objectID = msgbuffers.validate_integer(
      'ObjectTapped.objectID', value, 0, 4294967295)

  @property
  def numTaps(self):
    "uint_8 numTaps struct property."
    return self._numTaps

  @numTaps.setter
  def numTaps(self, value):
    self._numTaps = msgbuffers.validate_integer(
      'ObjectTapped.numTaps', value, 0, 255)

  @property
  def tapTime(self):
    "uint_8 tapTime struct property."
    return self._tapTime

  @tapTime.setter
  def tapTime(self, value):
    self._tapTime = msgbuffers.validate_integer(
      'ObjectTapped.tapTime', value, 0, 255)

  @property
  def tapNeg(self):
    "int_8 tapNeg struct property."
    return self._tapNeg

  @tapNeg.setter
  def tapNeg(self, value):
    self._tapNeg = msgbuffers.validate_integer(
      'ObjectTapped.tapNeg', value, -128, 127)

  @property
  def tapPos(self):
    "int_8 tapPos struct property."
    return self._tapPos

  @tapPos.setter
  def tapPos(self, value):
    self._tapPos = msgbuffers.validate_integer(
      'ObjectTapped.tapPos', value, -128, 127)

  def __init__(self, timestamp=0, objectID=0, numTaps=0, tapTime=0, tapNeg=0, tapPos=0):
    self.timestamp = timestamp
    self.objectID = objectID
    self.numTaps = numTaps
    self.tapTime = tapTime
    self.tapNeg = tapNeg
    self.tapPos = tapPos

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ObjectTapped from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ObjectTapped.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ObjectTapped from the given BinaryReader."
    _timestamp = reader.read('I')
    _objectID = reader.read('I')
    _numTaps = reader.read('B')
    _tapTime = reader.read('B')
    _tapNeg = reader.read('b')
    _tapPos = reader.read('b')
    return cls(_timestamp, _objectID, _numTaps, _tapTime, _tapNeg, _tapPos)

  def pack(self):
    "Writes the current ObjectTapped, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ObjectTapped to the given BinaryWriter."
    writer.write(self._timestamp, 'I')
    writer.write(self._objectID, 'I')
    writer.write(self._numTaps, 'B')
    writer.write(self._tapTime, 'B')
    writer.write(self._tapNeg, 'b')
    writer.write(self._tapPos, 'b')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._timestamp == other._timestamp and
        self._objectID == other._objectID and
        self._numTaps == other._numTaps and
        self._tapTime == other._tapTime and
        self._tapNeg == other._tapNeg and
        self._tapPos == other._tapPos)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._timestamp, 'I') +
      msgbuffers.size(self._objectID, 'I') +
      msgbuffers.size(self._numTaps, 'B') +
      msgbuffers.size(self._tapTime, 'B') +
      msgbuffers.size(self._tapNeg, 'b') +
      msgbuffers.size(self._tapPos, 'b'))

  def __str__(self):
    return '{type}(timestamp={timestamp}, objectID={objectID}, numTaps={numTaps}, tapTime={tapTime}, tapNeg={tapNeg}, tapPos={tapPos})'.format(
      type=type(self).__name__,
      timestamp=self._timestamp,
      objectID=self._objectID,
      numTaps=self._numTaps,
      tapTime=self._tapTime,
      tapNeg=self._tapNeg,
      tapPos=self._tapPos)

  def __repr__(self):
    return '{type}(timestamp={timestamp}, objectID={objectID}, numTaps={numTaps}, tapTime={tapTime}, tapNeg={tapNeg}, tapPos={tapPos})'.format(
      type=type(self).__name__,
      timestamp=repr(self._timestamp),
      objectID=repr(self._objectID),
      numTaps=repr(self._numTaps),
      tapTime=repr(self._tapTime),
      tapNeg=repr(self._tapNeg),
      tapPos=repr(self._tapPos))

Anki.Cozmo.ObjectTapped = ObjectTapped
del ObjectTapped


class ObjectPowerLevel(object):
  "Generated message-passing message."

  __slots__ = (
    '_objectID',      # uint_32
    '_missedPackets', # uint_32
    '_batteryLevel',  # uint_8
  )

  @property
  def objectID(self):
    "uint_32 objectID struct property."
    return self._objectID

  @objectID.setter
  def objectID(self, value):
    self._objectID = msgbuffers.validate_integer(
      'ObjectPowerLevel.objectID', value, 0, 4294967295)

  @property
  def missedPackets(self):
    "uint_32 missedPackets struct property."
    return self._missedPackets

  @missedPackets.setter
  def missedPackets(self, value):
    self._missedPackets = msgbuffers.validate_integer(
      'ObjectPowerLevel.missedPackets', value, 0, 4294967295)

  @property
  def batteryLevel(self):
    "uint_8 batteryLevel struct property."
    return self._batteryLevel

  @batteryLevel.setter
  def batteryLevel(self, value):
    self._batteryLevel = msgbuffers.validate_integer(
      'ObjectPowerLevel.batteryLevel', value, 0, 255)

  def __init__(self, objectID=0, missedPackets=0, batteryLevel=0):
    self.objectID = objectID
    self.missedPackets = missedPackets
    self.batteryLevel = batteryLevel

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ObjectPowerLevel from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ObjectPowerLevel.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ObjectPowerLevel from the given BinaryReader."
    _objectID = reader.read('I')
    _missedPackets = reader.read('I')
    _batteryLevel = reader.read('B')
    return cls(_objectID, _missedPackets, _batteryLevel)

  def pack(self):
    "Writes the current ObjectPowerLevel, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ObjectPowerLevel to the given BinaryWriter."
    writer.write(self._objectID, 'I')
    writer.write(self._missedPackets, 'I')
    writer.write(self._batteryLevel, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._objectID == other._objectID and
        self._missedPackets == other._missedPackets and
        self._batteryLevel == other._batteryLevel)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._objectID, 'I') +
      msgbuffers.size(self._missedPackets, 'I') +
      msgbuffers.size(self._batteryLevel, 'B'))

  def __str__(self):
    return '{type}(objectID={objectID}, missedPackets={missedPackets}, batteryLevel={batteryLevel})'.format(
      type=type(self).__name__,
      objectID=self._objectID,
      missedPackets=self._missedPackets,
      batteryLevel=self._batteryLevel)

  def __repr__(self):
    return '{type}(objectID={objectID}, missedPackets={missedPackets}, batteryLevel={batteryLevel})'.format(
      type=type(self).__name__,
      objectID=repr(self._objectID),
      missedPackets=repr(self._missedPackets),
      batteryLevel=repr(self._batteryLevel))

Anki.Cozmo.ObjectPowerLevel = ObjectPowerLevel
del ObjectPowerLevel


class ObjectAccel(object):
  "Generated message-passing message."

  __slots__ = (
    '_timestamp', # uint_32
    '_objectID',  # uint_32
    '_accel',     # Anki.Cozmo.ActiveAccel
  )

  @property
  def timestamp(self):
    "uint_32 timestamp struct property."
    return self._timestamp

  @timestamp.setter
  def timestamp(self, value):
    self._timestamp = msgbuffers.validate_integer(
      'ObjectAccel.timestamp', value, 0, 4294967295)

  @property
  def objectID(self):
    "uint_32 objectID struct property."
    return self._objectID

  @objectID.setter
  def objectID(self, value):
    self._objectID = msgbuffers.validate_integer(
      'ObjectAccel.objectID', value, 0, 4294967295)

  @property
  def accel(self):
    "Anki.Cozmo.ActiveAccel accel struct property."
    return self._accel

  @accel.setter
  def accel(self, value):
    self._accel = msgbuffers.validate_object(
      'ObjectAccel.accel', value, Anki.Cozmo.ActiveAccel)

  def __init__(self, timestamp=0, objectID=0, accel=Anki.Cozmo.ActiveAccel()):
    self.timestamp = timestamp
    self.objectID = objectID
    self.accel = accel

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ObjectAccel from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ObjectAccel.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ObjectAccel from the given BinaryReader."
    _timestamp = reader.read('I')
    _objectID = reader.read('I')
    _accel = reader.read_object(Anki.Cozmo.ActiveAccel.unpack_from)
    return cls(_timestamp, _objectID, _accel)

  def pack(self):
    "Writes the current ObjectAccel, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ObjectAccel to the given BinaryWriter."
    writer.write(self._timestamp, 'I')
    writer.write(self._objectID, 'I')
    writer.write_object(self._accel)

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._timestamp == other._timestamp and
        self._objectID == other._objectID and
        self._accel == other._accel)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._timestamp, 'I') +
      msgbuffers.size(self._objectID, 'I') +
      msgbuffers.size_object(self._accel))

  def __str__(self):
    return '{type}(timestamp={timestamp}, objectID={objectID}, accel={accel})'.format(
      type=type(self).__name__,
      timestamp=self._timestamp,
      objectID=self._objectID,
      accel=self._accel)

  def __repr__(self):
    return '{type}(timestamp={timestamp}, objectID={objectID}, accel={accel})'.format(
      type=type(self).__name__,
      timestamp=repr(self._timestamp),
      objectID=repr(self._objectID),
      accel=repr(self._accel))

Anki.Cozmo.ObjectAccel = ObjectAccel
del ObjectAccel


