# Copyright (c) 2016-2017 Anki, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License in the file LICENSE.txt or at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Autogenerated python message buffer code.
Source: clad/types/behaviorSystem/reactionTriggers.clad
Full command line: '../tools/message-buffers/emitters/Python_emitter.py' '-C' './src/' '-I' '../robot/clad/src/' '../coretech/vision/clad/src/' '../coretech/common/clad/src/' '../lib/util/source/anki/clad' '-o' '../generated/cladPython//' 'clad/types/behaviorSystem/reactionTriggers.clad'
"""

from __future__ import absolute_import
from __future__ import print_function

def _modify_path():
  import inspect, os, sys
  search_paths = [
    '../../..',
    '../../../../../tools/message-buffers/support/python',
  ]
  currentpath = os.path.abspath(os.path.dirname(inspect.getfile(inspect.currentframe())))
  for search_path in search_paths:
    search_path = os.path.normpath(os.path.abspath(os.path.realpath(os.path.join(currentpath, search_path))))
    if search_path not in sys.path:
      sys.path.insert(0, search_path)
_modify_path()

import msgbuffers

Anki = msgbuffers.Namespace()
Anki.Cozmo = msgbuffers.Namespace()

from clad.types.behaviorSystem.behaviorTypes import Anki as _Anki
Anki.update(_Anki.deep_clone())

class ReactionTrigger(object):
  "Automatically-generated uint_8 enumeration."
  CliffDetected         = 0
  CubeMoved             = 1
  FacePositionUpdated   = 2
  FistBump              = 3
  Frustration           = 4
  Hiccup                = 5
  MotorCalibration      = 6
  NoPreDockPoses        = 7
  ObjectPositionUpdated = 8
  PlacedOnCharger       = 9
  PetInitialDetection   = 10
  RobotFalling          = 11
  RobotPickedUp         = 12
  RobotPlacedOnSlope    = 13
  ReturnedToTreads      = 14
  RobotOnBack           = 15
  RobotOnFace           = 16
  RobotOnSide           = 17
  RobotShaken           = 18
  Sparked               = 19
  UnexpectedMovement    = 20
  Count                 = 21
  NoneTrigger           = 22

Anki.Cozmo.ReactionTrigger = ReactionTrigger
del ReactionTrigger


class AllTriggersConsidered(object):
  "Generated message-passing structure."

  __slots__ = (
    '_cliffDetected',         # bool
    '_cubeMoved',             # bool
    '_facePositionUpdated',   # bool
    '_fistBump',              # bool
    '_frustration',           # bool
    '_hiccup',                # bool
    '_motorCalibration',      # bool
    '_noPreDockPoses',        # bool
    '_objectPositionUpdated', # bool
    '_placedOnCharger',       # bool
    '_petInitialDetection',   # bool
    '_robotFalling',          # bool
    '_robotPickedUp',         # bool
    '_robotPlacedOnSlope',    # bool
    '_returnedToTreads',      # bool
    '_robotOnBack',           # bool
    '_robotOnFace',           # bool
    '_robotOnSide',           # bool
    '_robotShaken',           # bool
    '_sparked',               # bool
    '_unexpectedMovement',    # bool
  )

  @property
  def cliffDetected(self):
    "bool cliffDetected struct property."
    return self._cliffDetected

  @cliffDetected.setter
  def cliffDetected(self, value):
    self._cliffDetected = msgbuffers.validate_bool(
      'AllTriggersConsidered.cliffDetected', value)

  @property
  def cubeMoved(self):
    "bool cubeMoved struct property."
    return self._cubeMoved

  @cubeMoved.setter
  def cubeMoved(self, value):
    self._cubeMoved = msgbuffers.validate_bool(
      'AllTriggersConsidered.cubeMoved', value)

  @property
  def facePositionUpdated(self):
    "bool facePositionUpdated struct property."
    return self._facePositionUpdated

  @facePositionUpdated.setter
  def facePositionUpdated(self, value):
    self._facePositionUpdated = msgbuffers.validate_bool(
      'AllTriggersConsidered.facePositionUpdated', value)

  @property
  def fistBump(self):
    "bool fistBump struct property."
    return self._fistBump

  @fistBump.setter
  def fistBump(self, value):
    self._fistBump = msgbuffers.validate_bool(
      'AllTriggersConsidered.fistBump', value)

  @property
  def frustration(self):
    "bool frustration struct property."
    return self._frustration

  @frustration.setter
  def frustration(self, value):
    self._frustration = msgbuffers.validate_bool(
      'AllTriggersConsidered.frustration', value)

  @property
  def hiccup(self):
    "bool hiccup struct property."
    return self._hiccup

  @hiccup.setter
  def hiccup(self, value):
    self._hiccup = msgbuffers.validate_bool(
      'AllTriggersConsidered.hiccup', value)

  @property
  def motorCalibration(self):
    "bool motorCalibration struct property."
    return self._motorCalibration

  @motorCalibration.setter
  def motorCalibration(self, value):
    self._motorCalibration = msgbuffers.validate_bool(
      'AllTriggersConsidered.motorCalibration', value)

  @property
  def noPreDockPoses(self):
    "bool noPreDockPoses struct property."
    return self._noPreDockPoses

  @noPreDockPoses.setter
  def noPreDockPoses(self, value):
    self._noPreDockPoses = msgbuffers.validate_bool(
      'AllTriggersConsidered.noPreDockPoses', value)

  @property
  def objectPositionUpdated(self):
    "bool objectPositionUpdated struct property."
    return self._objectPositionUpdated

  @objectPositionUpdated.setter
  def objectPositionUpdated(self, value):
    self._objectPositionUpdated = msgbuffers.validate_bool(
      'AllTriggersConsidered.objectPositionUpdated', value)

  @property
  def placedOnCharger(self):
    "bool placedOnCharger struct property."
    return self._placedOnCharger

  @placedOnCharger.setter
  def placedOnCharger(self, value):
    self._placedOnCharger = msgbuffers.validate_bool(
      'AllTriggersConsidered.placedOnCharger', value)

  @property
  def petInitialDetection(self):
    "bool petInitialDetection struct property."
    return self._petInitialDetection

  @petInitialDetection.setter
  def petInitialDetection(self, value):
    self._petInitialDetection = msgbuffers.validate_bool(
      'AllTriggersConsidered.petInitialDetection', value)

  @property
  def robotFalling(self):
    "bool robotFalling struct property."
    return self._robotFalling

  @robotFalling.setter
  def robotFalling(self, value):
    self._robotFalling = msgbuffers.validate_bool(
      'AllTriggersConsidered.robotFalling', value)

  @property
  def robotPickedUp(self):
    "bool robotPickedUp struct property."
    return self._robotPickedUp

  @robotPickedUp.setter
  def robotPickedUp(self, value):
    self._robotPickedUp = msgbuffers.validate_bool(
      'AllTriggersConsidered.robotPickedUp', value)

  @property
  def robotPlacedOnSlope(self):
    "bool robotPlacedOnSlope struct property."
    return self._robotPlacedOnSlope

  @robotPlacedOnSlope.setter
  def robotPlacedOnSlope(self, value):
    self._robotPlacedOnSlope = msgbuffers.validate_bool(
      'AllTriggersConsidered.robotPlacedOnSlope', value)

  @property
  def returnedToTreads(self):
    "bool returnedToTreads struct property."
    return self._returnedToTreads

  @returnedToTreads.setter
  def returnedToTreads(self, value):
    self._returnedToTreads = msgbuffers.validate_bool(
      'AllTriggersConsidered.returnedToTreads', value)

  @property
  def robotOnBack(self):
    "bool robotOnBack struct property."
    return self._robotOnBack

  @robotOnBack.setter
  def robotOnBack(self, value):
    self._robotOnBack = msgbuffers.validate_bool(
      'AllTriggersConsidered.robotOnBack', value)

  @property
  def robotOnFace(self):
    "bool robotOnFace struct property."
    return self._robotOnFace

  @robotOnFace.setter
  def robotOnFace(self, value):
    self._robotOnFace = msgbuffers.validate_bool(
      'AllTriggersConsidered.robotOnFace', value)

  @property
  def robotOnSide(self):
    "bool robotOnSide struct property."
    return self._robotOnSide

  @robotOnSide.setter
  def robotOnSide(self, value):
    self._robotOnSide = msgbuffers.validate_bool(
      'AllTriggersConsidered.robotOnSide', value)

  @property
  def robotShaken(self):
    "bool robotShaken struct property."
    return self._robotShaken

  @robotShaken.setter
  def robotShaken(self, value):
    self._robotShaken = msgbuffers.validate_bool(
      'AllTriggersConsidered.robotShaken', value)

  @property
  def sparked(self):
    "bool sparked struct property."
    return self._sparked

  @sparked.setter
  def sparked(self, value):
    self._sparked = msgbuffers.validate_bool(
      'AllTriggersConsidered.sparked', value)

  @property
  def unexpectedMovement(self):
    "bool unexpectedMovement struct property."
    return self._unexpectedMovement

  @unexpectedMovement.setter
  def unexpectedMovement(self, value):
    self._unexpectedMovement = msgbuffers.validate_bool(
      'AllTriggersConsidered.unexpectedMovement', value)

  def __init__(self, cliffDetected, cubeMoved, facePositionUpdated, fistBump, frustration, hiccup, motorCalibration, noPreDockPoses, objectPositionUpdated, placedOnCharger, petInitialDetection, robotFalling, robotPickedUp, robotPlacedOnSlope, returnedToTreads, robotOnBack, robotOnFace, robotOnSide, robotShaken, sparked, unexpectedMovement):
    self.cliffDetected = cliffDetected
    self.cubeMoved = cubeMoved
    self.facePositionUpdated = facePositionUpdated
    self.fistBump = fistBump
    self.frustration = frustration
    self.hiccup = hiccup
    self.motorCalibration = motorCalibration
    self.noPreDockPoses = noPreDockPoses
    self.objectPositionUpdated = objectPositionUpdated
    self.placedOnCharger = placedOnCharger
    self.petInitialDetection = petInitialDetection
    self.robotFalling = robotFalling
    self.robotPickedUp = robotPickedUp
    self.robotPlacedOnSlope = robotPlacedOnSlope
    self.returnedToTreads = returnedToTreads
    self.robotOnBack = robotOnBack
    self.robotOnFace = robotOnFace
    self.robotOnSide = robotOnSide
    self.robotShaken = robotShaken
    self.sparked = sparked
    self.unexpectedMovement = unexpectedMovement

  @classmethod
  def unpack(cls, buffer):
    "Reads a new AllTriggersConsidered from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('AllTriggersConsidered.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new AllTriggersConsidered from the given BinaryReader."
    _cliffDetected = bool(reader.read('b'))
    _cubeMoved = bool(reader.read('b'))
    _facePositionUpdated = bool(reader.read('b'))
    _fistBump = bool(reader.read('b'))
    _frustration = bool(reader.read('b'))
    _hiccup = bool(reader.read('b'))
    _motorCalibration = bool(reader.read('b'))
    _noPreDockPoses = bool(reader.read('b'))
    _objectPositionUpdated = bool(reader.read('b'))
    _placedOnCharger = bool(reader.read('b'))
    _petInitialDetection = bool(reader.read('b'))
    _robotFalling = bool(reader.read('b'))
    _robotPickedUp = bool(reader.read('b'))
    _robotPlacedOnSlope = bool(reader.read('b'))
    _returnedToTreads = bool(reader.read('b'))
    _robotOnBack = bool(reader.read('b'))
    _robotOnFace = bool(reader.read('b'))
    _robotOnSide = bool(reader.read('b'))
    _robotShaken = bool(reader.read('b'))
    _sparked = bool(reader.read('b'))
    _unexpectedMovement = bool(reader.read('b'))
    return cls(_cliffDetected, _cubeMoved, _facePositionUpdated, _fistBump, _frustration, _hiccup, _motorCalibration, _noPreDockPoses, _objectPositionUpdated, _placedOnCharger, _petInitialDetection, _robotFalling, _robotPickedUp, _robotPlacedOnSlope, _returnedToTreads, _robotOnBack, _robotOnFace, _robotOnSide, _robotShaken, _sparked, _unexpectedMovement)

  def pack(self):
    "Writes the current AllTriggersConsidered, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current AllTriggersConsidered to the given BinaryWriter."
    writer.write(int(self._cliffDetected), 'b')
    writer.write(int(self._cubeMoved), 'b')
    writer.write(int(self._facePositionUpdated), 'b')
    writer.write(int(self._fistBump), 'b')
    writer.write(int(self._frustration), 'b')
    writer.write(int(self._hiccup), 'b')
    writer.write(int(self._motorCalibration), 'b')
    writer.write(int(self._noPreDockPoses), 'b')
    writer.write(int(self._objectPositionUpdated), 'b')
    writer.write(int(self._placedOnCharger), 'b')
    writer.write(int(self._petInitialDetection), 'b')
    writer.write(int(self._robotFalling), 'b')
    writer.write(int(self._robotPickedUp), 'b')
    writer.write(int(self._robotPlacedOnSlope), 'b')
    writer.write(int(self._returnedToTreads), 'b')
    writer.write(int(self._robotOnBack), 'b')
    writer.write(int(self._robotOnFace), 'b')
    writer.write(int(self._robotOnSide), 'b')
    writer.write(int(self._robotShaken), 'b')
    writer.write(int(self._sparked), 'b')
    writer.write(int(self._unexpectedMovement), 'b')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._cliffDetected == other._cliffDetected and
        self._cubeMoved == other._cubeMoved and
        self._facePositionUpdated == other._facePositionUpdated and
        self._fistBump == other._fistBump and
        self._frustration == other._frustration and
        self._hiccup == other._hiccup and
        self._motorCalibration == other._motorCalibration and
        self._noPreDockPoses == other._noPreDockPoses and
        self._objectPositionUpdated == other._objectPositionUpdated and
        self._placedOnCharger == other._placedOnCharger and
        self._petInitialDetection == other._petInitialDetection and
        self._robotFalling == other._robotFalling and
        self._robotPickedUp == other._robotPickedUp and
        self._robotPlacedOnSlope == other._robotPlacedOnSlope and
        self._returnedToTreads == other._returnedToTreads and
        self._robotOnBack == other._robotOnBack and
        self._robotOnFace == other._robotOnFace and
        self._robotOnSide == other._robotOnSide and
        self._robotShaken == other._robotShaken and
        self._sparked == other._sparked and
        self._unexpectedMovement == other._unexpectedMovement)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._cliffDetected, 'b') +
      msgbuffers.size(self._cubeMoved, 'b') +
      msgbuffers.size(self._facePositionUpdated, 'b') +
      msgbuffers.size(self._fistBump, 'b') +
      msgbuffers.size(self._frustration, 'b') +
      msgbuffers.size(self._hiccup, 'b') +
      msgbuffers.size(self._motorCalibration, 'b') +
      msgbuffers.size(self._noPreDockPoses, 'b') +
      msgbuffers.size(self._objectPositionUpdated, 'b') +
      msgbuffers.size(self._placedOnCharger, 'b') +
      msgbuffers.size(self._petInitialDetection, 'b') +
      msgbuffers.size(self._robotFalling, 'b') +
      msgbuffers.size(self._robotPickedUp, 'b') +
      msgbuffers.size(self._robotPlacedOnSlope, 'b') +
      msgbuffers.size(self._returnedToTreads, 'b') +
      msgbuffers.size(self._robotOnBack, 'b') +
      msgbuffers.size(self._robotOnFace, 'b') +
      msgbuffers.size(self._robotOnSide, 'b') +
      msgbuffers.size(self._robotShaken, 'b') +
      msgbuffers.size(self._sparked, 'b') +
      msgbuffers.size(self._unexpectedMovement, 'b'))

  def __str__(self):
    return '{type}(cliffDetected={cliffDetected}, cubeMoved={cubeMoved}, facePositionUpdated={facePositionUpdated}, fistBump={fistBump}, frustration={frustration}, hiccup={hiccup}, motorCalibration={motorCalibration}, noPreDockPoses={noPreDockPoses}, objectPositionUpdated={objectPositionUpdated}, placedOnCharger={placedOnCharger}, petInitialDetection={petInitialDetection}, robotFalling={robotFalling}, robotPickedUp={robotPickedUp}, robotPlacedOnSlope={robotPlacedOnSlope}, returnedToTreads={returnedToTreads}, robotOnBack={robotOnBack}, robotOnFace={robotOnFace}, robotOnSide={robotOnSide}, robotShaken={robotShaken}, sparked={sparked}, unexpectedMovement={unexpectedMovement})'.format(
      type=type(self).__name__,
      cliffDetected=self._cliffDetected,
      cubeMoved=self._cubeMoved,
      facePositionUpdated=self._facePositionUpdated,
      fistBump=self._fistBump,
      frustration=self._frustration,
      hiccup=self._hiccup,
      motorCalibration=self._motorCalibration,
      noPreDockPoses=self._noPreDockPoses,
      objectPositionUpdated=self._objectPositionUpdated,
      placedOnCharger=self._placedOnCharger,
      petInitialDetection=self._petInitialDetection,
      robotFalling=self._robotFalling,
      robotPickedUp=self._robotPickedUp,
      robotPlacedOnSlope=self._robotPlacedOnSlope,
      returnedToTreads=self._returnedToTreads,
      robotOnBack=self._robotOnBack,
      robotOnFace=self._robotOnFace,
      robotOnSide=self._robotOnSide,
      robotShaken=self._robotShaken,
      sparked=self._sparked,
      unexpectedMovement=self._unexpectedMovement)

  def __repr__(self):
    return '{type}(cliffDetected={cliffDetected}, cubeMoved={cubeMoved}, facePositionUpdated={facePositionUpdated}, fistBump={fistBump}, frustration={frustration}, hiccup={hiccup}, motorCalibration={motorCalibration}, noPreDockPoses={noPreDockPoses}, objectPositionUpdated={objectPositionUpdated}, placedOnCharger={placedOnCharger}, petInitialDetection={petInitialDetection}, robotFalling={robotFalling}, robotPickedUp={robotPickedUp}, robotPlacedOnSlope={robotPlacedOnSlope}, returnedToTreads={returnedToTreads}, robotOnBack={robotOnBack}, robotOnFace={robotOnFace}, robotOnSide={robotOnSide}, robotShaken={robotShaken}, sparked={sparked}, unexpectedMovement={unexpectedMovement})'.format(
      type=type(self).__name__,
      cliffDetected=repr(self._cliffDetected),
      cubeMoved=repr(self._cubeMoved),
      facePositionUpdated=repr(self._facePositionUpdated),
      fistBump=repr(self._fistBump),
      frustration=repr(self._frustration),
      hiccup=repr(self._hiccup),
      motorCalibration=repr(self._motorCalibration),
      noPreDockPoses=repr(self._noPreDockPoses),
      objectPositionUpdated=repr(self._objectPositionUpdated),
      placedOnCharger=repr(self._placedOnCharger),
      petInitialDetection=repr(self._petInitialDetection),
      robotFalling=repr(self._robotFalling),
      robotPickedUp=repr(self._robotPickedUp),
      robotPlacedOnSlope=repr(self._robotPlacedOnSlope),
      returnedToTreads=repr(self._returnedToTreads),
      robotOnBack=repr(self._robotOnBack),
      robotOnFace=repr(self._robotOnFace),
      robotOnSide=repr(self._robotOnSide),
      robotShaken=repr(self._robotShaken),
      sparked=repr(self._sparked),
      unexpectedMovement=repr(self._unexpectedMovement))

Anki.Cozmo.AllTriggersConsidered = AllTriggersConsidered
del AllTriggersConsidered


class ReactionTriggerToBehavior(object):
  "Generated message-passing structure."

  __slots__ = (
    '_trigger',    # Anki.Cozmo.ReactionTrigger
    '_behaviorID', # Anki.Cozmo.BehaviorID
  )

  @property
  def trigger(self):
    "Anki.Cozmo.ReactionTrigger trigger struct property."
    return self._trigger

  @trigger.setter
  def trigger(self, value):
    self._trigger = msgbuffers.validate_integer(
      'ReactionTriggerToBehavior.trigger', value, 0, 255)

  @property
  def behaviorID(self):
    "Anki.Cozmo.BehaviorID behaviorID struct property."
    return self._behaviorID

  @behaviorID.setter
  def behaviorID(self, value):
    self._behaviorID = msgbuffers.validate_integer(
      'ReactionTriggerToBehavior.behaviorID', value, 0, 255)

  def __init__(self, trigger=Anki.Cozmo.ReactionTrigger.CliffDetected, behaviorID=Anki.Cozmo.BehaviorID.AcknowledgeFace):
    self.trigger = trigger
    self.behaviorID = behaviorID

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ReactionTriggerToBehavior from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ReactionTriggerToBehavior.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ReactionTriggerToBehavior from the given BinaryReader."
    _trigger = reader.read('B')
    _behaviorID = reader.read('B')
    return cls(_trigger, _behaviorID)

  def pack(self):
    "Writes the current ReactionTriggerToBehavior, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ReactionTriggerToBehavior to the given BinaryWriter."
    writer.write(self._trigger, 'B')
    writer.write(self._behaviorID, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._trigger == other._trigger and
        self._behaviorID == other._behaviorID)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._trigger, 'B') +
      msgbuffers.size(self._behaviorID, 'B'))

  def __str__(self):
    return '{type}(trigger={trigger}, behaviorID={behaviorID})'.format(
      type=type(self).__name__,
      trigger=self._trigger,
      behaviorID=self._behaviorID)

  def __repr__(self):
    return '{type}(trigger={trigger}, behaviorID={behaviorID})'.format(
      type=type(self).__name__,
      trigger=repr(self._trigger),
      behaviorID=repr(self._behaviorID))

Anki.Cozmo.ReactionTriggerToBehavior = ReactionTriggerToBehavior
del ReactionTriggerToBehavior


